#### 多态
> 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。


 http://www.cnblogs.com/Darren_code/archive/2011/08/31/JavascripDesignPatterns.html
 
* 单例模式：
> 保证每个类仅有一个实例

* 策略模式：
> 定义一系列算法、把它们一个个封装起来，并且是他们可以相互替换，接受请求，委托给某个策略 

* 代理模式
> 此模式最基本的形式是对访问进行控制。代理对象和另一个对象（本体）实现的是同样的接口，可是实际上工作还是本体在做，它才是负责执行所分派的任务的那个对象或类，代理对象不会在另以对象的基础上修改任何方法，也不会简化那个对象的接口

* 迭代器模式 
> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示. Array.prototype.forEach

* 观察者模式
> 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

* 命令模式
>1. 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
>2. 命名模式的主要用途是把调用对象（用户界面，API和代理等）与实现操作的对象隔离开，也就是说使对象间的互动方式需要更高的模块化时都可以用到这种模式





* 职责链模式：chain of responsibility
>  使用多个对象都有机会处理请求，依次传递，直到一个能处理 （电商促销活动，不同条件，不同优惠；）(为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。)
 
* 中介者模式：mediator
> 中介者使得对象之间解耦，中介者和对象之间的一对多关系取代了对象间多对多的关系（ 多队玩家竞技游戏；）

* 装饰者模式: decorator
> 在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。（before after）

* 状态模式：state
> 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类